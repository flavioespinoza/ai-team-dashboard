===== src/types/global.d.ts =====
// Date: 2025-11-04
// Version: 1.0.0

declare global {
	var mongoose: {
		conn: typeof import('mongoose') | null
		promise: Promise<typeof import('mongoose')> | null
	}
}

export {}
===== src/app/actions.ts =====
// Date: 2025-11-04
// Version: 1.1.0

'use server'

import { connectDB } from '@/db'
import { IKnowledgeBase, KnowledgeBase } from '@/db/schema'
import OpenAI from 'openai'
import { z } from 'zod'

const openai = new OpenAI({
	apiKey: process.env.OPENAI_API_KEY
})

// Validation schemas
const questionSchema = z.string().min(1, 'Question cannot be empty').max(2000)
const tagsSchema = z.array(z.string()).optional()

type ServerActionResponse<T = unknown> = {
	success: boolean
	data?: T
	error?: string
}

/**
 * Ask the AI assistant a question
 */
export async function askAssistant(question: string): Promise<ServerActionResponse<string>> {
	try {
		// Validate input
		const validatedQuestion = questionSchema.parse(question)

		// Call OpenAI API
		const completion = await openai.chat.completions.create({
			model: 'gpt-4o-mini',
			messages: [
				{
					role: 'system',
					content:
						'You are a helpful AI assistant for an internal team. Provide clear, concise, and actionable answers.'
				},
				{
					role: 'user',
					content: validatedQuestion
				}
			],
			temperature: 0.7,
			max_tokens: 1000
		})

		const answer = completion.choices[0]?.message?.content || ''

		if (!answer) {
			throw new Error('No response from AI assistant')
		}

		return {
			success: true,
			data: answer
		}
	} catch (error) {
		console.error('Error in askAssistant:', error)

		if (error instanceof z.ZodError) {
			return {
				success: false,
				error: error.issues[0]?.message || 'Invalid question format'
			}
		}

		if (error instanceof Error) {
			return {
				success: false,
				error: error.message
			}
		}

		return {
			success: false,
			error: 'Failed to get response from AI assistant'
		}
	}
}

/**
 * Save a Q&A pair to the knowledge base
 */
export async function saveToKnowledgeBase(
	question: string,
	answer: string,
	tags?: string[]
): Promise<ServerActionResponse<IKnowledgeBase>> {
	try {
		// Validate inputs
		const validatedQuestion = questionSchema.parse(question)
		const validatedAnswer = z.string().min(1).parse(answer)
		const validatedTags = tagsSchema.parse(tags)

		// Connect to database
		await connectDB()

		// Create new knowledge base entry
		const entry = await KnowledgeBase.create({
			question: validatedQuestion,
			answer: validatedAnswer,
			tags: validatedTags || [],
			isPinned: false
		})

		// Convert to plain object
		const plainEntry = entry.toObject() as IKnowledgeBase
		plainEntry._id = entry._id.toString()

		return {
			success: true,
			data: plainEntry
		}
	} catch (error) {
		console.error('Error in saveToKnowledgeBase:', error)

		if (error instanceof z.ZodError) {
			return {
				success: false,
				error: error.issues[0]?.message || 'Invalid input format'
			}
		}

		if (error instanceof Error) {
			return {
				success: false,
				error: error.message
			}
		}

		return {
			success: false,
			error: 'Failed to save to knowledge base'
		}
	}
}

/**
 * Get all knowledge base entries
 */
export async function getKnowledgeBase(): Promise<ServerActionResponse<IKnowledgeBase[]>> {
	try {
		// Connect to database
		await connectDB()

		// Fetch all entries, sorted by most recent first
		const entries = await KnowledgeBase.find().sort({ createdAt: -1 }).lean().exec()

		// Convert ObjectId to string
		const plainEntries = entries.map((entry) => ({
			...entry,
			_id: entry._id?.toString() || ''
		})) as unknown as IKnowledgeBase[]

		return {
			success: true,
			data: plainEntries
		}
	} catch (error) {
		console.error('Error in getKnowledgeBase:', error)

		if (error instanceof Error) {
			return {
				success: false,
				error: error.message
			}
		}

		return {
			success: false,
			error: 'Failed to fetch knowledge base'
		}
	}
}

/**
 * Delete a knowledge base entry by ID
 */
export async function deleteKnowledgeBaseItem(id: string): Promise<ServerActionResponse<void>> {
	try {
		// Validate ID
		const validatedId = z.string().min(1).parse(id)

		// Connect to database
		await connectDB()

		// Delete the entry
		const result = await KnowledgeBase.findByIdAndDelete(validatedId)

		if (!result) {
			throw new Error('Knowledge base item not found')
		}

		return {
			success: true
		}
	} catch (error) {
		console.error('Error in deleteKnowledgeBaseItem:', error)

		if (error instanceof z.ZodError) {
			return {
				success: false,
				error: 'Invalid ID format'
			}
		}

		if (error instanceof Error) {
			return {
				success: false,
				error: error.message
			}
		}

		return {
			success: false,
			error: 'Failed to delete knowledge base item'
		}
	}
}

/**
 * Toggle the pinned status of a knowledge base entry
 */
export async function togglePinItem(id: string): Promise<ServerActionResponse<IKnowledgeBase>> {
	try {
		// Validate ID
		const validatedId = z.string().min(1).parse(id)

		// Connect to database
		await connectDB()

		// Find the entry
		const entry = await KnowledgeBase.findById(validatedId)

		if (!entry) {
			throw new Error('Knowledge base item not found')
		}

		// Toggle isPinned
		entry.isPinned = !entry.isPinned
		await entry.save()

		// Convert to plain object
		const plainEntry = entry.toObject() as IKnowledgeBase
		plainEntry._id = entry._id.toString()

		return {
			success: true,
			data: plainEntry
		}
	} catch (error) {
		console.error('Error in togglePinItem:', error)

		if (error instanceof z.ZodError) {
			return {
				success: false,
				error: 'Invalid ID format'
			}
		}

		if (error instanceof Error) {
			return {
				success: false,
				error: error.message
			}
		}

		return {
			success: false,
			error: 'Failed to toggle pin status'
		}
	}
}===== src/app/layout.tsx =====
import type { Metadata } from 'next'
import { Geist, Geist_Mono } from 'next/font/google'
import { Providers } from '@/components/providers'
import './globals.css'

const geistSans = Geist({
	variable: '--font-geist-sans',
	subsets: ['latin']
})

const geistMono = Geist_Mono({
	variable: '--font-geist-mono',
	subsets: ['latin']
})

export const metadata: Metadata = {
	title: 'AI Team Dashboard',
	description: 'Internal Team Dashboard with AI Assistant'
}

export default function RootLayout({
	children
}: Readonly<{
	children: React.ReactNode
}>) {
	return (
		<html lang="en">
			<body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
				<Providers>{children}</Providers>
			</body>
		</html>
	)
}
===== src/app/page.tsx =====
// Date: 2025-11-04
// Version: 1.0.0

'use client'

import { useEffect, useState } from 'react'
import { getKnowledgeBase } from '@/app/actions'
import { ChatInterface } from '@/components/chat-interface'
import { KnowledgeBaseSidebar } from '@/components/knowledge-base-sidebar'
import { knowledgeBaseState } from '@/state/atoms'
import { useSetAtom } from 'jotai'

export default function Home() {
	const setKnowledgeBase = useSetAtom(knowledgeBaseState)
	const [isLoading, setIsLoading] = useState(true)
	const [error, setError] = useState<string | null>(null)

	// Load knowledge base on mount
	useEffect(() => {
		async function loadKnowledgeBase() {
			try {
				const result = await getKnowledgeBase()

				if (result.success && result.data) {
					setKnowledgeBase(result.data)
				} else {
					setError(result.error || 'Failed to load knowledge base')
				}
			} catch (err) {
				console.error('Error loading knowledge base:', err)
				setError('Failed to load knowledge base')
			} finally {
				setIsLoading(false)
			}
		}

		loadKnowledgeBase()
	}, [setKnowledgeBase])

	return (
		<div className="flex min-h-screen flex-col bg-gray-50 dark:bg-gray-900">
			{/* Header */}
			<header className="border-b border-gray-200 bg-white dark:border-gray-800 dark:bg-gray-950">
				<div className="container mx-auto px-4 py-4">
					<h1 className="text-2xl font-bold text-gray-900 dark:text-gray-100">AI Team Dashboard</h1>
					<p className="text-sm text-gray-600 dark:text-gray-400">
						Ask questions and build your knowledge base
					</p>
				</div>
			</header>

			{/* Main content */}
			<main className="container mx-auto flex flex-1 gap-4 overflow-hidden p-4">
				{isLoading ? (
					<div className="flex flex-1 items-center justify-center">
						<div className="text-center">
							<div className="mb-4 h-8 w-8 animate-spin rounded-full border-4 border-gray-300 border-t-blue-600"></div>
							<p className="text-gray-600 dark:text-gray-400">Loading...</p>
						</div>
					</div>
				) : error ? (
					<div className="flex flex-1 items-center justify-center">
						<div className="rounded-lg bg-red-50 p-4 text-red-800 dark:bg-red-900/20 dark:text-red-200">
							<p className="font-semibold">Error</p>
							<p className="text-sm">{error}</p>
						</div>
					</div>
				) : (
					<>
						{/* Chat Interface - Main area */}
						<div className="flex flex-1 flex-col overflow-hidden lg:w-2/3">
							<ChatInterface />
						</div>

						{/* Knowledge Base Sidebar */}
						<div className="hidden w-full overflow-hidden lg:block lg:w-1/3">
							<KnowledgeBaseSidebar />
						</div>
					</>
				)}
			</main>

			{/* Mobile Knowledge Base - Shows as separate section on mobile */}
			<div className="container mx-auto block px-4 pb-4 lg:hidden">
				<KnowledgeBaseSidebar />
			</div>
		</div>
	)
}
===== src/state/atoms.ts =====
// Date: 2025-11-04
// Version: 1.0.0
import { atom } from 'jotai'

export type Message = {
	id: string
	type: 'user' | 'assistant'
	content: string
	timestamp: Date
}

export type KnowledgeBaseItem = {
	_id: string
	question: string
	answer: string
	tags?: string[]
	isPinned: boolean
	createdAt: Date
	updatedAt: Date
}

export const messagesState = atom<Message[]>([])

export const knowledgeBaseState = atom<KnowledgeBaseItem[]>([])

export const isLoadingState = atom<boolean>(false)

export const selectedKnowledgeItemState = atom<KnowledgeBaseItem | null>(null)
===== src/state/selectors.ts =====
// Date: 2025-11-04
// Version: 1.0.0
import { atom } from 'jotai'
import { knowledgeBaseState } from './atoms'

// Filter pinned items
export const pinnedItemsSelector = atom((get) => {
	const items = get(knowledgeBaseState)
	return items.filter((item) => item.isPinned)
})

// Sort by date (most recent first)
export const sortedKnowledgeBaseSelector = atom((get) => {
	const items = get(knowledgeBaseState)
	return [...items].sort(
		(a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
	)
})

// Sort with pinned items first, then by date
export const sortedWithPinnedFirstSelector = atom((get) => {
	const items = get(knowledgeBaseState)
	return [...items].sort((a, b) => {
		// Pinned items come first
		if (a.isPinned && !b.isPinned) return -1
		if (!a.isPinned && b.isPinned) return 1
		// Within same pin status, sort by date
		return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
	})
})
===== src/components/ui/card.tsx =====
// Date: 2025-11-04
// Version: 1.0.0
import { HTMLAttributes, forwardRef } from 'react'
import { cn } from '@/lib/utils'

const Card = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
	({ className, ...props }, ref) => (
		<div
			ref={ref}
			className={cn(
				'rounded-lg border border-gray-200 bg-white shadow-sm dark:border-gray-800 dark:bg-gray-950',
				className
			)}
			{...props}
		/>
	)
)
Card.displayName = 'Card'

const CardHeader = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
	({ className, ...props }, ref) => (
		<div ref={ref} className={cn('flex flex-col space-y-1.5 p-6', className)} {...props} />
	)
)
CardHeader.displayName = 'CardHeader'

const CardTitle = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLHeadingElement>>(
	({ className, ...props }, ref) => (
		<h3
			ref={ref}
			className={cn('text-lg leading-none font-semibold tracking-tight', className)}
			{...props}
		/>
	)
)
CardTitle.displayName = 'CardTitle'

const CardDescription = forwardRef<HTMLParagraphElement, HTMLAttributes<HTMLParagraphElement>>(
	({ className, ...props }, ref) => (
		<p ref={ref} className={cn('text-sm text-gray-500 dark:text-gray-400', className)} {...props} />
	)
)
CardDescription.displayName = 'CardDescription'

const CardContent = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
	({ className, ...props }, ref) => (
		<div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
	)
)
CardContent.displayName = 'CardContent'

const CardFooter = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
	({ className, ...props }, ref) => (
		<div ref={ref} className={cn('flex items-center p-6 pt-0', className)} {...props} />
	)
)
CardFooter.displayName = 'CardFooter'

export { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle }
===== src/components/ui/scroll-area.tsx =====
// Date: 2025-11-04
// Version: 1.0.0
import { HTMLAttributes, forwardRef } from 'react'
import { cn } from '@/lib/utils'

export interface ScrollAreaProps extends HTMLAttributes<HTMLDivElement> {}

const ScrollArea = forwardRef<HTMLDivElement, ScrollAreaProps>(
	({ className, children, ...props }, ref) => {
		return (
			<div ref={ref} className={cn('relative overflow-auto', className)} {...props}>
				<div className="h-full w-full">{children}</div>
			</div>
		)
	}
)

ScrollArea.displayName = 'ScrollArea'

export { ScrollArea }
===== src/components/ui/badge.tsx =====
// Date: 2025-11-04
// Version: 1.0.0
import { HTMLAttributes } from 'react'
import { cn } from '@/lib/utils'

export interface BadgeProps extends HTMLAttributes<HTMLDivElement> {
	variant?: 'default' | 'secondary' | 'success' | 'warning' | 'destructive'
}

function Badge({ className, variant = 'default', ...props }: BadgeProps) {
	return (
		<div
			className={cn(
				'inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-semibold transition-colors',
				{
					'bg-blue-100 text-blue-900 dark:bg-blue-900 dark:text-blue-100': variant === 'default',
					'bg-gray-100 text-gray-900 dark:bg-gray-800 dark:text-gray-100': variant === 'secondary',
					'bg-green-100 text-green-900 dark:bg-green-900 dark:text-green-100':
						variant === 'success',
					'bg-yellow-100 text-yellow-900 dark:bg-yellow-900 dark:text-yellow-100':
						variant === 'warning',
					'bg-red-100 text-red-900 dark:bg-red-900 dark:text-red-100': variant === 'destructive'
				},
				className
			)}
			{...props}
		/>
	)
}

export { Badge }
===== src/components/ui/button.tsx =====
// Date: 2025-11-04
// Version: 1.0.0
import { ButtonHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/lib/utils'

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
	variant?: 'default' | 'ghost' | 'outline'
	size?: 'sm' | 'md' | 'lg'
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant = 'default', size = 'md', ...props }, ref) => {
		return (
			<button
				className={cn(
					'inline-flex items-center justify-center rounded-md font-medium transition-colors',
					'focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none',
					'disabled:pointer-events-none disabled:opacity-50',
					{
						// Variants
						'bg-blue-600 text-white hover:bg-blue-700 focus-visible:ring-blue-600':
							variant === 'default',
						'hover:bg-gray-100 hover:text-gray-900 dark:hover:bg-gray-800 dark:hover:text-gray-100':
							variant === 'ghost',
						'border border-gray-300 bg-transparent hover:bg-gray-100 dark:border-gray-700 dark:hover:bg-gray-800':
							variant === 'outline',
						// Sizes
						'h-8 px-3 text-sm': size === 'sm',
						'h-10 px-4 text-base': size === 'md',
						'h-12 px-6 text-lg': size === 'lg'
					},
					className
				)}
				ref={ref}
				{...props}
			/>
		)
	}
)

Button.displayName = 'Button'

export { Button }
===== src/components/ui/input.tsx =====
// Date: 2025-11-04
// Version: 1.0.0
import { InputHTMLAttributes, TextareaHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/lib/utils'

export interface InputProps extends InputHTMLAttributes<HTMLInputElement> {}

const Input = forwardRef<HTMLInputElement, InputProps>(({ className, type, ...props }, ref) => {
	return (
		<input
			type={type}
			className={cn(
				'flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm',
				'focus-visible:ring-2 focus-visible:ring-blue-600 focus-visible:ring-offset-2 focus-visible:outline-none',
				'disabled:cursor-not-allowed disabled:opacity-50',
				'dark:border-gray-700 dark:bg-gray-950 dark:text-gray-100',
				className
			)}
			ref={ref}
			{...props}
		/>
	)
})

Input.displayName = 'Input'

export interface TextareaProps extends TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {
	return (
		<textarea
			className={cn(
				'flex min-h-[80px] w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm',
				'focus-visible:ring-2 focus-visible:ring-blue-600 focus-visible:ring-offset-2 focus-visible:outline-none',
				'disabled:cursor-not-allowed disabled:opacity-50',
				'dark:border-gray-700 dark:bg-gray-950 dark:text-gray-100',
				className
			)}
			ref={ref}
			{...props}
		/>
	)
})

Textarea.displayName = 'Textarea'

export { Input, Textarea }
===== src/components/knowledge-base-item.tsx =====
// Date: 2025-11-04
// Version: 1.0.0

'use client'

import { useState } from 'react'
import ReactMarkdown from 'react-markdown'
import { deleteKnowledgeBaseItem, togglePinItem } from '@/app/actions'
import { type KnowledgeBaseItem, knowledgeBaseState } from '@/state/atoms'
import { useSetAtom } from 'jotai'
import { Badge } from './ui/badge'
import { Button } from './ui/button'
import { Card, CardContent, CardHeader, CardTitle } from './ui/card'

interface KnowledgeBaseItemProps {
	item: KnowledgeBaseItem
}

export function KnowledgeBaseItemComponent({ item }: KnowledgeBaseItemProps) {
	const [isExpanded, setIsExpanded] = useState(false)
	const [isDeleting, setIsDeleting] = useState(false)
	const [isTogglingPin, setIsTogglingPin] = useState(false)
	const setKnowledgeBase = useSetAtom(knowledgeBaseState)

	const handleDelete = async () => {
		if (!confirm('Are you sure you want to delete this item?')) {
			return
		}

		setIsDeleting(true)
		try {
			const result = await deleteKnowledgeBaseItem(item._id)

			if (result.success) {
				setKnowledgeBase((prev) => prev.filter((i) => i._id !== item._id))
			}
		} catch (error) {
			console.error('Error deleting item:', error)
		} finally {
			setIsDeleting(false)
		}
	}

	const handleTogglePin = async () => {
		setIsTogglingPin(true)
		try {
			const result = await togglePinItem(item._id)

			if (result.success && result.data) {
				setKnowledgeBase((prev) =>
					prev.map((i) => (i._id === item._id ? { ...i, isPinned: result.data!.isPinned } : i))
				)
			}
		} catch (error) {
			console.error('Error toggling pin:', error)
		} finally {
			setIsTogglingPin(false)
		}
	}

	const answerPreview = item.answer.length > 150 ? `${item.answer.slice(0, 150)}...` : item.answer

	const createdAt = new Date(item.createdAt).toLocaleDateString('en-US', {
		month: 'short',
		day: 'numeric',
		year: 'numeric'
	})

	return (
		<Card className="transition-shadow hover:shadow-md">
			<CardHeader className="pb-3">
				<div className="flex items-start justify-between gap-2">
					<CardTitle className="line-clamp-2 text-base">{item.question}</CardTitle>
					<div className="flex gap-1">
						<Button
							size="sm"
							variant="ghost"
							onClick={handleTogglePin}
							disabled={isTogglingPin}
							className="h-8 w-8 p-0"
						>
							{item.isPinned ? 'üìå' : 'üìç'}
						</Button>
						<Button
							size="sm"
							variant="ghost"
							onClick={handleDelete}
							disabled={isDeleting}
							className="h-8 w-8 p-0 text-red-600 hover:bg-red-50 hover:text-red-700"
						>
							üóëÔ∏è
						</Button>
					</div>
				</div>
				<div className="flex flex-wrap gap-2">
					{item.isPinned && <Badge variant="warning">Pinned</Badge>}
					{item.tags && item.tags.length > 0 && (
						<>
							{item.tags.map((tag) => (
								<Badge key={tag} variant="secondary">
									{tag}
								</Badge>
							))}
						</>
					)}
				</div>
			</CardHeader>
			<CardContent>
				<div className="mb-2">
					{isExpanded ? (
						<ReactMarkdown
							className="prose prose-sm dark:prose-invert max-w-none"
							components={{
								p: ({ children }) => <p className="mb-2 last:mb-0">{children}</p>,
								code: ({ children }) => (
									<code className="rounded bg-gray-200 px-1 py-0.5 text-sm dark:bg-gray-700">
										{children}
									</code>
								),
								pre: ({ children }) => (
									<pre className="my-2 overflow-x-auto rounded bg-gray-200 p-2 dark:bg-gray-700">
										{children}
									</pre>
								)
							}}
						>
							{item.answer}
						</ReactMarkdown>
					) : (
						<p className="text-sm text-gray-600 dark:text-gray-400">{answerPreview}</p>
					)}
				</div>
				<div className="flex items-center justify-between">
					<span className="text-xs text-gray-500">{createdAt}</span>
					<Button size="sm" variant="ghost" onClick={() => setIsExpanded(!isExpanded)}>
						{isExpanded ? 'Show less' : 'Show more'}
					</Button>
				</div>
			</CardContent>
		</Card>
	)
}
===== src/components/knowledge-base-sidebar.tsx =====
// Date: 2025-11-04
// Version: 1.0.0

'use client'

import { useState } from 'react'
import { sortedWithPinnedFirstSelector } from '@/state/selectors'
import { useAtomValue } from 'jotai'
import { KnowledgeBaseItemComponent } from './knowledge-base-item'
import { Card, CardContent, CardHeader, CardTitle } from './ui/card'
import { Input } from './ui/input'
import { ScrollArea } from './ui/scroll-area'

export function KnowledgeBaseSidebar() {
	const knowledgeBaseItems = useAtomValue(sortedWithPinnedFirstSelector)
	const [searchQuery, setSearchQuery] = useState('')

	// Filter items based on search query
	const filteredItems = knowledgeBaseItems.filter((item) => {
		const query = searchQuery.toLowerCase()
		return (
			item.question.toLowerCase().includes(query) ||
			item.answer.toLowerCase().includes(query) ||
			item.tags?.some((tag) => tag.toLowerCase().includes(query))
		)
	})

	return (
		<Card className="flex h-full flex-col">
			<CardHeader>
				<CardTitle>Knowledge Base</CardTitle>
				<Input
					type="text"
					placeholder="Search knowledge base..."
					value={searchQuery}
					onChange={(e) => setSearchQuery(e.target.value)}
					className="mt-2"
				/>
			</CardHeader>
			<CardContent className="flex flex-1 flex-col overflow-hidden">
				<ScrollArea className="flex-1 pr-4">
					<div className="flex flex-col gap-4">
						{filteredItems.length === 0 ? (
							<div className="flex h-full items-center justify-center text-center text-gray-500">
								<p>
									{searchQuery
										? 'No items found matching your search'
										: 'No saved items yet. Save answers from the chat to build your knowledge base.'}
								</p>
							</div>
						) : (
							filteredItems.map((item) => <KnowledgeBaseItemComponent key={item._id} item={item} />)
						)}
					</div>
				</ScrollArea>
			</CardContent>
		</Card>
	)
}
===== src/components/chat-interface.tsx =====
// Date: 2025-11-04
// Version: 1.2.0

'use client'

import { FormEvent, useEffect, useRef, useState } from 'react'
import { MessageSquarePlus } from 'lucide-react'
import { useAtom } from 'jotai'
import { askAssistant } from '@/app/actions'
import { MessageComponent } from '@/components/message'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Textarea } from '@/components/ui/input'
import { messagesState } from '@/state/atoms'

export function ChatInterface() {
	const [messages, setMessages] = useAtom(messagesState)
	const [question, setQuestion] = useState('')
	const [isSubmitting, setIsSubmitting] = useState(false)
	const [error, setError] = useState<string | null>(null)
	const scrollRef = useRef<HTMLDivElement>(null)
	const textareaRef = useRef<HTMLTextAreaElement>(null)

	// Auto-scroll to bottom when new messages arrive
	useEffect(() => {
		if (scrollRef.current) {
			const scrollElement = scrollRef.current.querySelector('[data-radix-scroll-area-viewport]')
			if (scrollElement) {
				scrollElement.scrollTop = scrollElement.scrollHeight
			}
		}
	}, [messages])

	const handleSubmit = async (e: FormEvent) => {
		e.preventDefault()

		if (!question.trim() || isSubmitting) {
			return
		}

		setError(null)
		setIsSubmitting(true)

		// Add user message
		const userMessage = {
			id: Date.now().toString(),
			type: 'user' as const,
			content: question.trim(),
			timestamp: new Date()
		}

		setMessages((prev) => [...prev, userMessage])
		setQuestion('')

		try {
			// Call AI assistant
			const result = await askAssistant(userMessage.content)

			if (result.success && result.data) {
				// Add assistant message
				const assistantMessage = {
					id: (Date.now() + 1).toString(),
					type: 'assistant' as const,
					content: result.data,
					timestamp: new Date()
				}

				setMessages((prev) => [...prev, assistantMessage])
			} else {
				setError(result.error || 'Failed to get response from AI assistant')
			}
		} catch (err) {
			setError('An unexpected error occurred')
			console.error('Error asking assistant:', err)
		} finally {
			setIsSubmitting(false)
			// Focus back on textarea
			textareaRef.current?.focus()
		}
	}

	const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
		if (e.key === 'Enter' && !e.shiftKey) {
			e.preventDefault()
			handleSubmit(e)
		}
	}

	const handleNewChat = () => {
		setMessages([])
		setQuestion('')
		setError(null)
		textareaRef.current?.focus()
	}

	return (
		<Card className="flex h-full flex-col">
			<CardHeader>
				<div className="flex items-center justify-between">
					<CardTitle>AI Assistant</CardTitle>
					<Button
						variant="outline"
						size="sm"
						onClick={handleNewChat}
						disabled={messages.length === 0}
						className="gap-2"
					>
						<MessageSquarePlus className="h-4 w-4" />
						New Chat
					</Button>
				</div>
			</CardHeader>
			<CardContent className="flex flex-1 flex-col gap-4 overflow-hidden">
				{/* Messages area */}
				<ScrollArea ref={scrollRef} className="flex-1 pr-4">
					<div className="flex flex-col gap-4">
						{messages.length === 0 ? (
							<div className="flex h-full items-center justify-center text-gray-500">
								<p>Ask a question to get started</p>
							</div>
						) : (
							messages.map((message, index) => (
								<MessageComponent
									key={message.id}
									message={message}
									previousMessage={index > 0 ? messages[index - 1] : undefined}
								/>
							))
						)}
						{isSubmitting && (
							<div className="flex justify-start">
								<div className="max-w-[80%] rounded-lg bg-gray-100 p-4 text-gray-900 dark:bg-gray-800 dark:text-gray-100">
									<div className="flex items-center gap-2">
										<div className="h-2 w-2 animate-pulse rounded-full bg-gray-600"></div>
										<div className="animation-delay-200 h-2 w-2 animate-pulse rounded-full bg-gray-600"></div>
										<div className="animation-delay-400 h-2 w-2 animate-pulse rounded-full bg-gray-600"></div>
										<span className="ml-2 text-sm">Thinking...</span>
									</div>
								</div>
							</div>
						)}
					</div>
				</ScrollArea>

				{/* Error message */}
				{error && (
					<div className="rounded-md bg-red-50 p-3 text-sm text-red-800 dark:bg-red-900/20 dark:text-red-200">
						{error}
					</div>
				)}

				{/* Input area */}
				<form onSubmit={handleSubmit} className="flex gap-2">
					<Textarea
						ref={textareaRef}
						value={question}
						onChange={(e) => setQuestion(e.target.value)}
						onKeyDown={handleKeyDown}
						placeholder="Ask a question... (Press Enter to send, Shift+Enter for new line)"
						className="min-h-[80px] resize-none"
						disabled={isSubmitting}
					/>
					<Button type="submit" disabled={!question.trim() || isSubmitting} className="self-end">
						{isSubmitting ? 'Sending...' : 'Ask'}
					</Button>
				</form>
			</CardContent>
		</Card>
	)
}===== src/components/message.tsx =====
// Date: 2025-11-04
// Version: 1.2.0

'use client'

import { useState } from 'react'
import { useSetAtom } from 'jotai'
import ReactMarkdown from 'react-markdown'
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism'
import { saveToKnowledgeBase } from '@/app/actions'
import { type Message, knowledgeBaseState } from '@/state/atoms'
import { Button } from './ui/button'

interface MessageProps {
	message: Message
	previousMessage?: Message
}

export function MessageComponent({ message, previousMessage }: MessageProps) {
	const [isSaving, setIsSaving] = useState(false)
	const [saved, setSaved] = useState(false)
	const setKnowledgeBase = useSetAtom(knowledgeBaseState)

	const handleSave = async () => {
		if (!previousMessage || previousMessage.type !== 'user') {
			return
		}

		setIsSaving(true)
		try {
			const result = await saveToKnowledgeBase(previousMessage.content, message.content)

			if (result.success && result.data) {
				setKnowledgeBase((prev) => [result.data!, ...prev])
				setSaved(true)
			}
		} catch (error) {
			console.error('Error saving to knowledge base:', error)
		} finally {
			setIsSaving(false)
		}
	}

	const timestamp = new Date(message.timestamp).toLocaleTimeString('en-US', {
		hour: 'numeric',
		minute: '2-digit'
	})

	const isUser = message.type === 'user'

	return (
		<div className={`flex gap-3 ${isUser ? 'justify-end' : 'justify-start'}`}>
			<div
				className={`max-w-[80%] rounded-lg p-4 ${
					isUser
						? 'bg-blue-600 text-white'
						: 'bg-gray-100 text-gray-900 dark:bg-gray-800 dark:text-gray-100'
				}`}
			>
				<div className="mb-2">
					<ReactMarkdown
						components={{
							p: ({ children }) => <p className="mb-2 last:mb-0">{children}</p>,
							code: ({ className, children, ...props }: any) => {
								const match = /language-(\w+)/.exec(className || '')
								const language = match ? match[1] : null
								const inline = !language

								if (!inline && language) {
									return (
										<SyntaxHighlighter
											style={vscDarkPlus}
											language={language}
											PreTag="div"
											customStyle={{
												margin: '0.5rem 0',
												borderRadius: '0.375rem',
												fontSize: '0.875rem'
											}}
											{...props}
										>
											{String(children).replace(/\n$/, '')}
										</SyntaxHighlighter>
									)
								}

								return (
									<code
										className={`rounded px-1 py-0.5 text-sm ${
											isUser ? 'bg-blue-700' : 'bg-gray-200 dark:bg-gray-700'
										}`}
										{...props}
									>
										{children}
									</code>
								)
							}
						}}
					>
						{message.content}
					</ReactMarkdown>
				</div>
				<div className="flex items-center justify-between gap-2">
					<span className="text-xs opacity-70">{timestamp}</span>
					{!isUser && previousMessage && (
						<Button
							size="sm"
							variant="outline"
							onClick={handleSave}
							disabled={isSaving || saved}
							className="text-xs"
						>
							{saved ? 'Saved' : isSaving ? 'Saving...' : 'Save to Knowledge Base'}
						</Button>
					)}
				</div>
			</div>
		</div>
	)
}===== src/components/providers.tsx =====
// Date: 2025-11-04
// Version: 1.0.0

'use client'

import { Provider } from 'jotai'

export function Providers({ children }: { children: React.ReactNode }) {
	return <Provider>{children}</Provider>
}
===== src/lib/utils.ts =====
// Date: 2025-11-04
// Version: 1.0.0
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs))
}
===== src/db/schema.ts =====
// Date: 2025-11-04
// Version: 1.0.0
import mongoose from 'mongoose'

const KnowledgeBaseSchema = new mongoose.Schema(
	{
		question: {
			type: String,
			required: true,
			trim: true
		},
		answer: {
			type: String,
			required: true
		},
		tags: {
			type: [String],
			default: []
		},
		isPinned: {
			type: Boolean,
			default: false
		}
	},
	{
		timestamps: true
	}
)

export const KnowledgeBase =
	mongoose.models.KnowledgeBase || mongoose.model('KnowledgeBase', KnowledgeBaseSchema)

export type IKnowledgeBase = {
	_id: string
	question: string
	answer: string
	tags?: string[]
	isPinned: boolean
	createdAt: Date
	updatedAt: Date
}
===== src/db/index.ts =====
// Date: 2025-11-04
// Version: 1.0.0
import mongoose from 'mongoose'

const MONGODB_URI = process.env.MONGODB_URI!
const MONGODB_DB = process.env.MONGODB_DB!

if (!MONGODB_URI) {
	throw new Error('Please define MONGODB_URI environment variable')
}

if (!MONGODB_DB) {
	throw new Error('Please define MONGODB_DB environment variable')
}

let cached = global.mongoose

if (!cached) {
	cached = global.mongoose = { conn: null, promise: null }
}

export async function connectDB() {
	if (cached.conn) {
		return cached.conn
	}

	if (!cached.promise) {
		cached.promise = mongoose
			.connect(MONGODB_URI, {
				dbName: MONGODB_DB,
				bufferCommands: false
			})
			.then((mongoose) => mongoose)
	}

	try {
		cached.conn = await cached.promise
	} catch (e) {
		cached.promise = null
		throw e
	}

	return cached.conn
}
